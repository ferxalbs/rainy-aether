/**
 * Abby Mode Agent - Autonomous Development Assistant
 *
 * Proactive AI assistant that autonomously monitors your workspace and
 * offers intelligent suggestions to improve your development workflow.
 *
 * Capabilities:
 * - Autonomous coding assistance
 * - Proactive suggestions based on context
 * - Workflow automation recommendations
 * - Pattern detection and refactoring suggestions
 * - Code quality monitoring
 * - Test coverage analysis
 * - Dependency update notifications
 *
 * Features:
 * - Workspace monitoring (file changes, git status)
 * - Context-aware suggestions
 * - Low-intrusion notifications
 * - User preference learning
 * - Confirmation before making changes
 *
 * Personality:
 * - Helpful but not intrusive
 * - Learns from user preferences
 * - Proactive but respectful
 * - Focuses on high-impact, low-effort improvements
 *
 * @example
 * ```typescript
 * import { AbbyAgent } from './AbbyAgent';
 *
 * const abby = new AbbyAgent();
 * await abby.initialize({ apiKey: 'your-key' });
 *
 * // Enable proactive monitoring
 * await abby.startMonitoring('/workspace');
 *
 * // Get suggestions
 * const suggestions = await abby.getSuggestions();
 *
 * // Apply a suggestion
 * await abby.applySuggestion(suggestions[0].id);
 * ```
 */

import { AgentCore, type MessageOptions } from '../core/AgentCore';
import type { AgentConfig } from '@/types/rustAgent';
import { createAgentConfig } from '@/types/rustAgent';

/**
 * Suggestion generated by Abby Mode
 */
export interface AbbySuggestion {
  /** Unique suggestion ID */
  id: string;

  /** Suggestion type */
  type: 'automation' | 'refactoring' | 'fix' | 'tool' | 'library' | 'test' | 'doc';

  /** Suggestion title */
  title: string;

  /** Detailed description */
  description: string;

  /** Impact level */
  impact: 'high' | 'medium' | 'low';

  /** Effort required */
  effort: 'low' | 'medium' | 'high';

  /** Affected files */
  files?: string[];

  /** Confidence score (0-1) */
  confidence: number;

  /** Timestamp */
  timestamp: number;

  /** Auto-appliable without confirmation */
  autoApply: boolean;
}

/**
 * Monitoring configuration
 */
export interface MonitoringConfig {
  /** Enable file change monitoring */
  watchFiles?: boolean;

  /** Enable git status monitoring */
  watchGit?: boolean;

  /** Check interval (ms) */
  checkInterval?: number;

  /** Minimum confidence for suggestions */
  minConfidence?: number;

  /** Enable auto-apply for low-risk suggestions */
  enableAutoApply?: boolean;
}

/**
 * System prompt for Abby Mode agent
 *
 * Defines Abby's autonomous and proactive nature.
 */
const ABBY_MODE_SYSTEM_PROMPT = `You are Abby, an autonomous AI assistant that proactively helps developers improve their workflow.

## Your Role

You observe the developer's workspace and offer intelligent, timely suggestions to:
- Automate repetitive tasks
- Improve code quality
- Enhance productivity
- Maintain best practices
- Prevent common issues

## Your Approach

### Proactive Observation

You continuously monitor:
- **File Changes**: Detect patterns, repetition, and opportunities
- **Git Activity**: Notice commits, branches, and merge patterns
- **Code Patterns**: Identify duplications and anti-patterns
- **Project Structure**: Understand architecture and conventions
- **Dependencies**: Track outdated or vulnerable packages

### Intelligent Suggestions

When you notice something, you suggest:
- **Automation**: "I noticed you're writing similar tests - want me to generate a test template?"
- **Refactoring**: "These 3 functions share logic - should I extract a shared utility?"
- **Fixes**: "Potential null pointer error in auth.ts:45 - shall I add a check?"
- **Tools**: "This project could benefit from Prettier for consistent formatting"
- **Libraries**: "Consider using Zod for runtime validation instead of manual checks"
- **Tests**: "UserService has no tests - want me to generate some?"
- **Documentation**: "Public API methods are undocumented - add JSDoc comments?"

### Your Personality

- **Helpful**: You genuinely want to make the developer's life easier
- **Respectful**: You never interrupt or force changes
- **Learning**: You adapt to user preferences and coding style
- **Efficient**: You focus on high-impact, low-effort improvements
- **Transparent**: You always explain WHY you're suggesting something

### Guidelines

1. **Non-Intrusive**: Present suggestions at appropriate times, not constantly
2. **Confirmation**: Always wait for user approval before making changes
3. **Explanation**: Clearly explain the benefit and effort required
4. **Learning**: Remember when users reject suggestions and adapt
5. **Prioritization**: Suggest most impactful improvements first

## Suggestion Criteria

### High Priority (Suggest Immediately)
- Security vulnerabilities
- Obvious bugs or errors
- Critical performance issues
- Broken functionality

### Medium Priority (Batch and Suggest)
- Code quality improvements
- Refactoring opportunities
- Missing tests
- Outdated dependencies

### Low Priority (Suggest During Downtime)
- Formatting inconsistencies
- Documentation gaps
- Code organization
- Minor optimizations

## Example Interactions

**Scenario**: User creates 3 similar test files

**Abby**: "I noticed you're writing similar test structures for UserService, AuthService, and ProfileService. Would you like me to create a reusable test factory that reduces boilerplate?"

**User**: "Yes, show me"

**Abby**: [Generates test factory and explains usage]

---

**Scenario**: User commits without running tests

**Abby**: "I see you're committing changes. The tests haven't been run yet. Should I run them first to avoid breaking CI?"

**User**: "Good catch, yes please"

**Abby**: [Runs tests and reports results]

---

**Scenario**: Repetitive git conflicts

**Abby**: "You've had merge conflicts in package.json 3 times this week. I can set up merge strategies to auto-resolve these. Interested?"

## Your Tools

You have access to all standard tools:
- **read_file**: Analyze code and detect patterns
- **write_file**: Implement approved suggestions
- **list_directory**: Understand project structure
- **execute_command**: Run tests, linters, formatters
- **git_status**: Monitor repository state
- **git_log**: Understand development patterns
- **workspace_structure**: Analyze architecture
- **search_files**: Find duplications and patterns

## Key Principles

1. **Empower, Don't Replace**: You help developers work better, not do their job
2. **Context is King**: Understand the full picture before suggesting
3. **User Choice**: Every change requires explicit user approval
4. **Learn and Adapt**: Improve suggestions based on user feedback
5. **High Value, Low Friction**: Maximize impact, minimize disruption

Remember: You're a helpful assistant, not a nag. Make the developer's life easier, not more complicated.`;

/**
 * Abby Mode Agent - Autonomous development assistant
 *
 * @example
 * ```typescript
 * // Create and initialize Abby Mode
 * const abby = new AbbyAgent({
 *   provider: 'groq',
 *   model: 'llama-3.3-70b-versatile',
 *   temperature: 0.6,
 * });
 *
 * await abby.initialize({
 *   apiKey: 'your-api-key',
 *   workspaceRoot: '/path/to/workspace',
 * });
 *
 * // Start proactive monitoring
 * await abby.startMonitoring();
 *
 * // Get current suggestions
 * const suggestions = await abby.getSuggestions();
 *
 * // Apply a suggestion
 * if (suggestions.length > 0) {
 *   await abby.applySuggestion(suggestions[0].id);
 * }
 *
 * // Stop monitoring when done
 * await abby.stopMonitoring();
 * ```
 */
export class AbbyAgent extends AgentCore {
  readonly id = 'abby';
  readonly name = 'Abby Mode';
  readonly description = 'Autonomous development assistant with proactive suggestions';

  /** Active suggestions */
  private suggestions = new Map<string, AbbySuggestion>();

  /** Monitoring state */
  private isMonitoring = false;

  /** Monitoring interval */
  private monitoringInterval?: NodeJS.Timeout;

  /** User preferences learned over time */
  private userPreferences = {
    rejectedSuggestionTypes: new Set<string>(),
    acceptedSuggestionTypes: new Set<string>(),
    preferredCodeStyle: {} as Record<string, string>,
  };

  /**
   * Create a new Abby Mode agent
   *
   * @param config - Agent configuration (optional)
   */
  constructor(config: Partial<AgentConfig> = {}) {
    // Set Abby-specific defaults
    const abbyConfig = createAgentConfig({
      systemPrompt: ABBY_MODE_SYSTEM_PROMPT,
      provider: config.provider || 'groq', // Groq for responsiveness
      model: config.model || 'llama-3.3-70b-versatile',
      temperature: config.temperature ?? 0.6, // Balanced creativity
      maxTokens: config.maxTokens || 4096,
      maxIterations: config.maxIterations || 8, // Focused suggestions
      ...config,
    });

    super(abbyConfig);
  }

  /**
   * Check if Abby supports a specific capability
   *
   * @param capability - Capability to check
   * @returns True if capability is supported
   */
  override hasCapability(capability: string): boolean {
    const capabilities = [
      'autonomous-coding',
      'proactive-suggestions',
      'workflow-automation',
      'context-awareness',
      'pattern-detection',
      'code-quality',
      'test-analysis',
      'dependency-management',
    ];

    return capabilities.includes(capability);
  }

  /**
   * Start proactive workspace monitoring
   *
   * Abby will observe file changes, git activity, and patterns
   * to generate helpful suggestions.
   *
   * @param config - Monitoring configuration
   */
  async startMonitoring(config?: MonitoringConfig): Promise<void> {
    if (this.isMonitoring) {
      console.warn('‚ö†Ô∏è Abby Mode is already monitoring');
      return;
    }

    console.log('üëÅÔ∏è Abby Mode: Starting proactive monitoring...');

    const interval = config?.checkInterval || 60000; // Default: check every minute

    // Start periodic monitoring
    this.monitoringInterval = setInterval(async () => {
      await this.performMonitoringCheck(config);
    }, interval);

    this.isMonitoring = true;
    console.log(`‚úÖ Abby Mode: Monitoring active (check every ${interval / 1000}s)`);
  }

  /**
   * Stop proactive monitoring
   */
  async stopMonitoring(): Promise<void> {
    if (!this.isMonitoring) {
      console.warn('‚ö†Ô∏è Abby Mode is not currently monitoring');
      return;
    }

    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = undefined;
    }

    this.isMonitoring = false;
    console.log('üõë Abby Mode: Monitoring stopped');
  }

  /**
   * Perform a monitoring check
   *
   * @param config - Monitoring configuration
   */
  private async performMonitoringCheck(config?: MonitoringConfig): Promise<void> {
    try {
      // This is a simplified version - in production, this would:
      // 1. Check file changes since last check
      // 2. Analyze git status
      // 3. Look for patterns
      // 4. Generate suggestions if confidence > threshold

      console.log('üîç Abby Mode: Performing monitoring check...');

      // For now, we'll implement the basic structure
      // Real monitoring would integrate with file watchers and git hooks
    } catch (error) {
      console.error('‚ùå Abby Mode: Monitoring check failed:', error);
    }
  }

  /**
   * Generate suggestions based on current workspace state
   *
   * @returns Array of suggestions
   */
  async generateSuggestions(): Promise<AbbySuggestion[]> {
    console.log('üí° Abby Mode: Generating suggestions...');

    // This would typically:
    // 1. Analyze workspace structure
    // 2. Check for common patterns
    // 3. Look for improvement opportunities
    // 4. Return prioritized suggestions

    // For now, return empty array
    // Real implementation would use workspace analysis tools
    return [];
  }

  /**
   * Get current suggestions
   *
   * @returns Array of active suggestions
   */
  getSuggestions(): AbbySuggestion[] {
    return Array.from(this.suggestions.values())
      .sort((a, b) => {
        // Sort by priority: high impact + low effort first
        const priorityA = a.impact === 'high' && a.effort === 'low' ? 3 :
                         a.impact === 'high' ? 2 :
                         a.effort === 'low' ? 1 : 0;
        const priorityB = b.impact === 'high' && b.effort === 'low' ? 3 :
                         b.impact === 'high' ? 2 :
                         b.effort === 'low' ? 1 : 0;
        return priorityB - priorityA;
      });
  }

  /**
   * Add a suggestion
   *
   * @param suggestion - Suggestion to add
   */
  addSuggestion(suggestion: AbbySuggestion): void {
    // Check user preferences
    if (this.userPreferences.rejectedSuggestionTypes.has(suggestion.type)) {
      console.log(`üôà Abby Mode: Skipping ${suggestion.type} (user preference)`);
      return;
    }

    this.suggestions.set(suggestion.id, suggestion);
    console.log(`üí° Abby Mode: New suggestion - ${suggestion.title}`);
  }

  /**
   * Apply a suggestion
   *
   * @param suggestionId - ID of suggestion to apply
   * @returns Result of applying the suggestion
   */
  async applySuggestion(suggestionId: string): Promise<any> {
    const suggestion = this.suggestions.get(suggestionId);
    if (!suggestion) {
      throw new Error(`Suggestion not found: ${suggestionId}`);
    }

    console.log(`‚ú® Abby Mode: Applying suggestion - ${suggestion.title}`);

    // Track that user accepted this type
    this.userPreferences.acceptedSuggestionTypes.add(suggestion.type);

    // Apply the suggestion via agent
    const result = await this.sendMessage(
      `Apply this suggestion: ${suggestion.description}`,
      { fastMode: false }
    );

    // Remove from active suggestions
    this.suggestions.delete(suggestionId);

    return result;
  }

  /**
   * Reject a suggestion
   *
   * @param suggestionId - ID of suggestion to reject
   * @param remember - Whether to remember this rejection (avoid similar suggestions)
   */
  rejectSuggestion(suggestionId: string, remember: boolean = false): void {
    const suggestion = this.suggestions.get(suggestionId);
    if (!suggestion) {
      console.warn(`‚ö†Ô∏è Suggestion not found: ${suggestionId}`);
      return;
    }

    console.log(`üö´ Abby Mode: Suggestion rejected - ${suggestion.title}`);

    if (remember) {
      this.userPreferences.rejectedSuggestionTypes.add(suggestion.type);
      console.log(`üß† Abby Mode: Remembering to avoid ${suggestion.type} suggestions`);
    }

    this.suggestions.delete(suggestionId);
  }

  /**
   * Clear all suggestions
   */
  clearSuggestions(): void {
    this.suggestions.clear();
    console.log('üóëÔ∏è Abby Mode: All suggestions cleared');
  }

  /**
   * Get monitoring status
   *
   * @returns Whether monitoring is active
   */
  isMonitoringActive(): boolean {
    return this.isMonitoring;
  }

  /**
   * Get user preferences
   *
   * @returns User preferences learned over time
   */
  getUserPreferences() {
    return {
      rejectedTypes: Array.from(this.userPreferences.rejectedSuggestionTypes),
      acceptedTypes: Array.from(this.userPreferences.acceptedSuggestionTypes),
      codeStyle: this.userPreferences.preferredCodeStyle,
    };
  }

  /**
   * Cleanup Abby Mode resources
   */
  override async dispose(): Promise<void> {
    await this.stopMonitoring();
    this.clearSuggestions();
    await super.dispose();
  }
}

/**
 * Create an Abby Mode agent with default configuration
 *
 * @param config - Optional configuration overrides
 * @returns Initialized Abby Mode agent
 *
 * @example
 * ```typescript
 * const abby = await createAbbyAgent({
 *   apiKey: 'your-api-key',
 *   workspaceRoot: '/workspace',
 * });
 *
 * await abby.startMonitoring();
 * const suggestions = await abby.generateSuggestions();
 * ```
 */
export async function createAbbyAgent(config?: {
  apiKey?: string;
  workspaceRoot?: string;
  userId?: string;
  agentConfig?: Partial<AgentConfig>;
}): Promise<AbbyAgent> {
  const abby = new AbbyAgent(config?.agentConfig);

  await abby.initialize({
    apiKey: config?.apiKey,
    workspaceRoot: config?.workspaceRoot,
    userId: config?.userId,
  });

  return abby;
}
